name: Release

on:
  push:
    branches:
      - main
    paths:
      - 'VERSION'

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
      id-token: write
    
    steps:
    - uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'
        cache: true
        cache-dependency-path: |
          go.sum
          go.mod

    - name: Read and validate version
      run: |
        echo "Reading version from VERSION file..."
        
        # Validate VERSION file exists and is readable
        if [[ ! -f "VERSION" ]]; then
          echo "Error: VERSION file not found"
          exit 1
        fi
        
        VERSION=$(cat VERSION | tr -d '[:space:]')
        if [[ -z "$VERSION" ]]; then
          echo "Error: VERSION file is empty"
          exit 1
        fi
        
        echo "Found version: $VERSION"
        
        # Validate version format (basic semantic version check)
        if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "Error: Version '$VERSION' is not a valid semantic version (X.Y.Z)"
          exit 1
        fi
        
        # Check if tag already exists
        if git tag -l "v$VERSION" | grep -q "v$VERSION"; then
          echo "Error: Tag v$VERSION already exists"
          exit 1
        fi
        
        echo "NEW_VERSION=$VERSION" >> $GITHUB_ENV
        echo "✓ Version validation completed: $VERSION"

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: us-east-1

    - name: Verify AWS authentication
      run: |
        echo "Verifying AWS authentication..."
        
        # Test AWS credentials
        if ! aws sts get-caller-identity > /dev/null 2>&1; then
          echo "Error: AWS authentication failed"
          exit 1
        fi
        
        echo "✓ AWS authentication successful"

    - name: Login to Amazon ECR Public
      uses: aws-actions/amazon-ecr-login@v2
      with:
        registry-type: public

    - name: Verify ECR authentication
      run: |
        echo "Verifying ECR public registry authentication..."
        
        # Test ECR authentication by attempting to describe repositories
        if ! aws ecr-public describe-repositories --region us-east-1 > /dev/null 2>&1; then
          echo "Error: ECR public registry authentication failed"
          exit 1
        fi
        
        echo "✓ ECR public registry authentication successful"

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Install OpenShift CLI
      run: |
        echo "Installing OpenShift CLI..."
        
        # Download with retry logic
        for i in {1..3}; do
          if curl -LO https://mirror.openshift.com/pub/openshift-v4/clients/ocp/stable/openshift-client-linux.tar.gz; then
            break
          elif [ $i -eq 3 ]; then
            echo "Error: Failed to download OpenShift CLI after 3 attempts"
            exit 1
          else
            echo "Download attempt $i failed, retrying..."
            sleep 5
          fi
        done
        
        tar -xzf openshift-client-linux.tar.gz
        sudo mv oc /usr/local/bin/
        
        # Verify installation
        if ! oc version --client; then
          echo "Error: OpenShift CLI installation failed"
          exit 1
        fi
        
        echo "✓ OpenShift CLI installed successfully"

    - name: Build and push images
      run: |
        echo "Building and pushing images for version: ${{ env.NEW_VERSION }}"
        
        # Build operator image
        echo "Building operator image..."
        if ! make docker-build PROJECT_VERSION=${{ env.NEW_VERSION }}; then
          echo "Error: Failed to build operator image"
          exit 1
        fi
        echo "✓ Operator image built and pushed successfully"
        
        # Generate bundle
        echo "Generating OLM bundle..."
        if ! make bundle PROJECT_VERSION=${{ env.NEW_VERSION }}; then
          echo "Error: Failed to generate bundle"
          exit 1
        fi
        echo "✓ Bundle generated successfully"
        
        # Build bundle image
        echo "Building bundle image..."
        if ! make bundle-build PROJECT_VERSION=${{ env.NEW_VERSION }}; then
          echo "Error: Failed to build bundle image"
          exit 1
        fi
        echo "✓ Bundle image built and pushed successfully"
        
        # Build index image
        echo "Building index image..."
        if ! make index PROJECT_VERSION=${{ env.NEW_VERSION }}; then
          echo "Error: Failed to build index image"
          exit 1
        fi
        echo "✓ Index image built and pushed successfully"
        
        echo "✓ All images built and pushed successfully"

    - name: Generate release manifests
      run: |
        echo "Generating release manifests for version: ${{ env.NEW_VERSION }}"
        
        if ! make release-manifests PROJECT_VERSION=${{ env.NEW_VERSION }}; then
          echo "Error: Failed to generate release manifests"
          exit 1
        fi
        
        # Validate generated manifests
        EXPECTED_FILES=(
          "release/${{ env.NEW_VERSION }}/aws-neuron-operator.yaml"
          "release/${{ env.NEW_VERSION }}/nfd-rule.yaml"
          "release/${{ env.NEW_VERSION }}/deviceconfig-sample.yaml"
        )
        
        for file in "${EXPECTED_FILES[@]}"; do
          if [[ ! -f "$file" ]]; then
            echo "Error: Missing expected manifest file: $file"
            exit 1
          fi
          
          if [[ ! -s "$file" ]]; then
            echo "Error: Manifest file is empty: $file"
            exit 1
          fi
          
          echo "✓ Validated: $file"
        done
        
        echo "✓ Release manifests generated and validated successfully"

    - name: Security scan release artifacts
      run: |
        echo "Running security scans on release artifacts..."
        
        # Install Trivy
        sudo apt-get update
        sudo apt-get install wget apt-transport-https gnupg lsb-release
        wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
        echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
        sudo apt-get update
        sudo apt-get install trivy
        
        # Scan the built image
        echo "Scanning operator image..."
        IMG="public.ecr.aws/q5p6u7h8/neuron-openshift/operator:v${{ env.NEW_VERSION }}"
        trivy image --severity HIGH,CRITICAL --exit-code 0 $IMG || {
          echo "⚠ High/Critical vulnerabilities found in operator image"
          echo "Review recommended but not blocking release"
        }
        
        # Scan Kubernetes manifests
        echo "Scanning Kubernetes manifests..."
        trivy config --severity HIGH,CRITICAL release/${{ env.NEW_VERSION }}/ || {
          echo "⚠ Security issues found in manifests"
          echo "Review recommended but not blocking release"
        }
        
        echo "✓ Security scans completed"

    - name: Commit and tag
      run: |
        echo "Configuring git and creating release tag..."
        
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        CURRENT_BRANCH=$(git branch --show-current)
        echo "Current branch: $CURRENT_BRANCH"
        
        # Create tag
        echo "Creating tag v${{ env.NEW_VERSION }}..."
        if ! git tag "v${{ env.NEW_VERSION }}"; then
          echo "Error: Failed to create tag"
          exit 1
        fi
        
        # Push tag with retry logic
        echo "Pushing tag to remote..."
        for i in {1..3}; do
          if git push origin "v${{ env.NEW_VERSION }}"; then
            echo "✓ Tag pushed successfully"
            break
          elif [ $i -eq 3 ]; then
            echo "Error: Failed to push tag after 3 attempts"
            exit 1
          else
            echo "Push attempt $i failed, retrying..."
            sleep 5
          fi
        done

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: "v${{ env.NEW_VERSION }}"
        name: "Release v${{ env.NEW_VERSION }}"
        body: |
          ## AWS Neuron Operator v${{ env.NEW_VERSION }}
          
          ### Quick Install
          ```bash
          kubectl apply -f https://github.com/awslabs/operator-for-ai-chips-on-aws/releases/download/v${{ env.NEW_VERSION }}/aws-neuron-operator.yaml
          kubectl apply -f https://github.com/awslabs/operator-for-ai-chips-on-aws/releases/download/v${{ env.NEW_VERSION }}/deviceconfig-sample.yaml
          ```
          
          ### Container Images
          
          **Direct Installation:**
          - Operator: `public.ecr.aws/q5p6u7h8/neuron-openshift/operator:v${{ env.NEW_VERSION }}`
          
          **OLM Installation:**
          - Bundle: `public.ecr.aws/q5p6u7h8/neuron-openshift/operator-bundle:v${{ env.NEW_VERSION }}`
          - Index: `public.ecr.aws/q5p6u7h8/neuron-openshift/operator-index:v${{ env.NEW_VERSION }}`
          
          ### Installation Methods
          
          **Option 1: Direct Install (Recommended)**
          ```bash
          # Install NFD and KMM operators from OperatorHub first
          kubectl apply -f https://github.com/awslabs/operator-for-ai-chips-on-aws/releases/download/v${{ env.NEW_VERSION }}/aws-neuron-operator.yaml
          kubectl apply -f https://github.com/awslabs/operator-for-ai-chips-on-aws/releases/download/v${{ env.NEW_VERSION }}/deviceconfig-sample.yaml
          ```
          
          **Option 2: OLM Install**
          ```bash
          # 1. Apply NFD rule first
          kubectl apply -f https://github.com/awslabs/operator-for-ai-chips-on-aws/releases/download/v${{ env.NEW_VERSION }}/nfd-rule.yaml
          
          # 2. Create namespace
          kubectl create namespace ai-operator-on-aws
          
          # 3. Create OperatorGroup
          kubectl apply -f - <<EOF
          apiVersion: operators.coreos.com/v1
          kind: OperatorGroup
          metadata:
            name: aws-neuron-operator
            namespace: ai-operator-on-aws
          EOF
          
          # 4. Create CatalogSource
          kubectl apply -f - <<EOF
          apiVersion: operators.coreos.com/v1alpha1
          kind: CatalogSource
          metadata:
            name: aws-neuron-operator
            namespace: openshift-marketplace
          spec:
            sourceType: grpc
            image: public.ecr.aws/q5p6u7h8/neuron-openshift/operator-index:v${{ env.NEW_VERSION }}
            displayName: AWS Neuron Operator Catalog
          EOF
          
          # 5. Create Subscription
          kubectl apply -f - <<EOF
          apiVersion: operators.coreos.com/v1alpha1
          kind: Subscription
          metadata:
            name: aws-neuron-operator-sub
            namespace: ai-operator-on-aws
          spec:
            channel: "alpha"
            installPlanApproval: Automatic
            name: aws-neuron-operator
            source: aws-neuron-operator
            sourceNamespace: openshift-marketplace
          EOF
          ```
          
          See [INSTALL.md](https://github.com/awslabs/operator-for-ai-chips-on-aws/blob/main/INSTALL.md) for detailed instructions.
        files: |
          release/${{ env.NEW_VERSION }}/aws-neuron-operator.yaml
          release/${{ env.NEW_VERSION }}/nfd-rule.yaml
          release/${{ env.NEW_VERSION }}/deviceconfig-sample.yaml
        generate_release_notes: true